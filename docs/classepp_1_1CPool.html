<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ECSpp: epp::CPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ECSpp
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>epp</b></li><li class="navelem"><a class="el" href="classepp_1_1CPool.html">CPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classepp_1_1CPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">epp::CPool Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="CPool_8h_source.html">CPool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3016062239c37162a1da5b48cf042655"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a3016062239c37162a1da5b48cf042655">CPool</a> (<a class="el" href="structepp_1_1IndexType.html">ComponentId</a> cId)</td></tr>
<tr class="memdesc:a3016062239c37162a1da5b48cf042655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a pool of the given component.  <a href="classepp_1_1CPool.html#a3016062239c37162a1da5b48cf042655">More...</a><br /></td></tr>
<tr class="separator:a3016062239c37162a1da5b48cf042655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3922714d2f749e7253eb2cb45908f60a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a3922714d2f749e7253eb2cb45908f60a">CPool</a> (<a class="el" href="classepp_1_1CPool.html">CPool</a> &amp;&amp;rval)</td></tr>
<tr class="memdesc:a3922714d2f749e7253eb2cb45908f60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classepp_1_1CPool.html#a3922714d2f749e7253eb2cb45908f60a">More...</a><br /></td></tr>
<tr class="separator:a3922714d2f749e7253eb2cb45908f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0025bec412cfc415a0ed8049ac71fc61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classepp_1_1CPool.html">CPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a0025bec412cfc415a0ed8049ac71fc61">operator=</a> (<a class="el" href="classepp_1_1CPool.html">CPool</a> &amp;&amp;rval)</td></tr>
<tr class="memdesc:a0025bec412cfc415a0ed8049ac71fc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="classepp_1_1CPool.html#a0025bec412cfc415a0ed8049ac71fc61">More...</a><br /></td></tr>
<tr class="separator:a0025bec412cfc415a0ed8049ac71fc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d41b0237b909e3532be1c20d7ab30a"><td class="memItemLeft" align="right" valign="top"><a id="af3d41b0237b909e3532be1c20d7ab30a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#af3d41b0237b909e3532be1c20d7ab30a">CPool</a> (<a class="el" href="classepp_1_1CPool.html">CPool</a> const &amp;)=delete</td></tr>
<tr class="memdesc:af3d41b0237b909e3532be1c20d7ab30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor. <br /></td></tr>
<tr class="separator:af3d41b0237b909e3532be1c20d7ab30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a0b14d4722fa6f3e9713f1b1a8465d"><td class="memItemLeft" align="right" valign="top"><a id="a42a0b14d4722fa6f3e9713f1b1a8465d"></a>
<a class="el" href="classepp_1_1CPool.html">CPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a42a0b14d4722fa6f3e9713f1b1a8465d">operator=</a> (<a class="el" href="classepp_1_1CPool.html">CPool</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a42a0b14d4722fa6f3e9713f1b1a8465d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment. <br /></td></tr>
<tr class="separator:a42a0b14d4722fa6f3e9713f1b1a8465d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086db7e609e3dec0983337527b493666"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a086db7e609e3dec0983337527b493666">~CPool</a> ()</td></tr>
<tr class="memdesc:a086db7e609e3dec0983337527b493666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classepp_1_1CPool.html#a086db7e609e3dec0983337527b493666">More...</a><br /></td></tr>
<tr class="separator:a086db7e609e3dec0983337527b493666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add00e7a2c7fd9f080c9ee8efdb71c729"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#add00e7a2c7fd9f080c9ee8efdb71c729">alloc</a> ()</td></tr>
<tr class="memdesc:add00e7a2c7fd9f080c9ee8efdb71c729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for one component.  <a href="classepp_1_1CPool.html#add00e7a2c7fd9f080c9ee8efdb71c729">More...</a><br /></td></tr>
<tr class="separator:add00e7a2c7fd9f080c9ee8efdb71c729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21df1711e13c0d620dfd1c2b03bd2aa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#ae21df1711e13c0d620dfd1c2b03bd2aa">alloc</a> (Idx_t n)</td></tr>
<tr class="memdesc:ae21df1711e13c0d620dfd1c2b03bd2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for n components.  <a href="classepp_1_1CPool.html#ae21df1711e13c0d620dfd1c2b03bd2aa">More...</a><br /></td></tr>
<tr class="separator:ae21df1711e13c0d620dfd1c2b03bd2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d386d6fd5d4f8abefc2d770b7b1d68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a39d386d6fd5d4f8abefc2d770b7b1d68">construct</a> (Idx_t idx)</td></tr>
<tr class="memdesc:a39d386d6fd5d4f8abefc2d770b7b1d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the constructor on the component located at the given index.  <a href="classepp_1_1CPool.html#a39d386d6fd5d4f8abefc2d770b7b1d68">More...</a><br /></td></tr>
<tr class="separator:a39d386d6fd5d4f8abefc2d770b7b1d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e79799d666f92fd6d419dd2be395a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#aa7e79799d666f92fd6d419dd2be395a5">construct</a> (Idx_t idx, void *rValComp)</td></tr>
<tr class="memdesc:aa7e79799d666f92fd6d419dd2be395a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the move constructor on the component located at the given index.  <a href="classepp_1_1CPool.html#aa7e79799d666f92fd6d419dd2be395a5">More...</a><br /></td></tr>
<tr class="separator:aa7e79799d666f92fd6d419dd2be395a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388e83315cca53345d7faedce6ee4a7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a388e83315cca53345d7faedce6ee4a7b">destroy</a> (Idx_t idx)</td></tr>
<tr class="memdesc:a388e83315cca53345d7faedce6ee4a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the destructor on the component located at the given index.  <a href="classepp_1_1CPool.html#a388e83315cca53345d7faedce6ee4a7b">More...</a><br /></td></tr>
<tr class="separator:a388e83315cca53345d7faedce6ee4a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531d5f11291ba779176d8122da6382fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a531d5f11291ba779176d8122da6382fb">fitNextN</a> (std::size_t n)</td></tr>
<tr class="memdesc:a531d5f11291ba779176d8122da6382fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next alloc(n) call or n <a class="el" href="classepp_1_1CPool.html#add00e7a2c7fd9f080c9ee8efdb71c729" title="Allocates memory for one component.">alloc()</a> calls will not require reallocation.  <a href="classepp_1_1CPool.html#a531d5f11291ba779176d8122da6382fb">More...</a><br /></td></tr>
<tr class="separator:a531d5f11291ba779176d8122da6382fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1afd7206166a896d45daa3c53c3536"><td class="memItemLeft" align="right" valign="top"><a id="a5c1afd7206166a896d45daa3c53c3536"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a5c1afd7206166a896d45daa3c53c3536">shrinkToFit</a> ()</td></tr>
<tr class="memdesc:a5c1afd7206166a896d45daa3c53c3536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the excess of the reserved memory. <br /></td></tr>
<tr class="separator:a5c1afd7206166a896d45daa3c53c3536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4546a94f6425051c0f63ff9da8895834"><td class="memItemLeft" align="right" valign="top"><a id="a4546a94f6425051c0f63ff9da8895834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a4546a94f6425051c0f63ff9da8895834">clear</a> ()</td></tr>
<tr class="memdesc:a4546a94f6425051c0f63ff9da8895834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys every component. <br /></td></tr>
<tr class="separator:a4546a94f6425051c0f63ff9da8895834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4075ebdecfdf17cfbf73bbc0c1157b05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a4075ebdecfdf17cfbf73bbc0c1157b05">reserve</a> (std::size_t newReserved)</td></tr>
<tr class="memdesc:a4075ebdecfdf17cfbf73bbc0c1157b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the capacity to exactly newReserved.  <a href="classepp_1_1CPool.html#a4075ebdecfdf17cfbf73bbc0c1157b05">More...</a><br /></td></tr>
<tr class="separator:a4075ebdecfdf17cfbf73bbc0c1157b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2b05a74ae78bda6c760d5e477ae3a7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#aca2b05a74ae78bda6c760d5e477ae3a7">operator[]</a> (Idx_t idx)</td></tr>
<tr class="memdesc:aca2b05a74ae78bda6c760d5e477ae3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the component located at the given index.  <a href="classepp_1_1CPool.html#aca2b05a74ae78bda6c760d5e477ae3a7">More...</a><br /></td></tr>
<tr class="separator:aca2b05a74ae78bda6c760d5e477ae3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709ac5e7931265dd9ada9681522921b3"><td class="memItemLeft" align="right" valign="top">void const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a709ac5e7931265dd9ada9681522921b3">operator[]</a> (Idx_t idx) const</td></tr>
<tr class="memdesc:a709ac5e7931265dd9ada9681522921b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the component located at the given index.  <a href="classepp_1_1CPool.html#a709ac5e7931265dd9ada9681522921b3">More...</a><br /></td></tr>
<tr class="separator:a709ac5e7931265dd9ada9681522921b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3776120ed4a8ed08f2ba8948ae280e58"><td class="memItemLeft" align="right" valign="top"><a id="a3776120ed4a8ed08f2ba8948ae280e58"></a>
<a class="el" href="structepp_1_1IndexType.html">ComponentId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#a3776120ed4a8ed08f2ba8948ae280e58">getCId</a> () const</td></tr>
<tr class="memdesc:a3776120ed4a8ed08f2ba8948ae280e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ComponentId of this pool. <br /></td></tr>
<tr class="separator:a3776120ed4a8ed08f2ba8948ae280e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e2f12cf23ebbcda96b56889aceb9fc"><td class="memItemLeft" align="right" valign="top"><a id="ae8e2f12cf23ebbcda96b56889aceb9fc"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#ae8e2f12cf23ebbcda96b56889aceb9fc">size</a> () const</td></tr>
<tr class="memdesc:ae8e2f12cf23ebbcda96b56889aceb9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of "used" components. <br /></td></tr>
<tr class="separator:ae8e2f12cf23ebbcda96b56889aceb9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e298ce6457a0092240dc0d617da5c8"><td class="memItemLeft" align="right" valign="top"><a id="ac9e298ce6457a0092240dc0d617da5c8"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepp_1_1CPool.html#ac9e298ce6457a0092240dc0d617da5c8">capacity</a> () const</td></tr>
<tr class="memdesc:ac9e298ce6457a0092240dc0d617da5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the pool (how many components can it fit without reallocation) <br /></td></tr>
<tr class="separator:ac9e298ce6457a0092240dc0d617da5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a76b6147c571224c877445c384860457c"><td class="memItemLeft" align="right" valign="top"><a id="a76b6147c571224c877445c384860457c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Idx_t</b> = std::size_t</td></tr>
<tr class="separator:a76b6147c571224c877445c384860457c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a807c500c6c5f4e777e562771565d4c1d"><td class="memItemLeft" align="right" valign="top"><a id="a807c500c6c5f4e777e562771565d4c1d"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>addressAtIdx</b> (Idx_t idx) const</td></tr>
<tr class="separator:a807c500c6c5f4e777e562771565d4c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1dc1c8165cbdf7e1aa9baf7937d7b4"><td class="memItemLeft" align="right" valign="top"><a id="a9d1dc1c8165cbdf7e1aa9baf7937d7b4"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>addressAtIdx</b> (void *base, Idx_t idx) const</td></tr>
<tr class="separator:a9d1dc1c8165cbdf7e1aa9baf7937d7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afd5e9bef90edf26b291ab4bfad606015"><td class="memItemLeft" align="right" valign="top"><a id="afd5e9bef90edf26b291ab4bfad606015"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> = nullptr</td></tr>
<tr class="separator:afd5e9bef90edf26b291ab4bfad606015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5626b1cb0d76ca4f03c5c4da04bfdd18"><td class="memItemLeft" align="right" valign="top"><a id="a5626b1cb0d76ca4f03c5c4da04bfdd18"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>reserved</b> = 0</td></tr>
<tr class="separator:a5626b1cb0d76ca4f03c5c4da04bfdd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b65b206a96ba980f5db63127230e37"><td class="memItemLeft" align="right" valign="top"><a id="a56b65b206a96ba980f5db63127230e37"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>dataUsed</b> = 0</td></tr>
<tr class="separator:a56b65b206a96ba980f5db63127230e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c07270c7c8041f25aac30d94c98d1d"><td class="memItemLeft" align="right" valign="top"><a id="a94c07270c7c8041f25aac30d94c98d1d"></a>
const <a class="el" href="classepp_1_1CMetadata.html">CMetadata</a>&#160;</td><td class="memItemRight" valign="bottom"><b>metadata</b></td></tr>
<tr class="separator:a94c07270c7c8041f25aac30d94c98d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Vector that uses <a class="el" href="classepp_1_1CMetadata.html">CMetadata</a> to manage the data without a type information Does not maintain order - the last component is always moved in the place of a removed one </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3016062239c37162a1da5b48cf042655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3016062239c37162a1da5b48cf042655">&#9670;&nbsp;</a></span>CPool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">epp::CPool::CPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structepp_1_1IndexType.html">ComponentId</a>&#160;</td>
          <td class="paramname"><em>cId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a pool of the given component. </p>
<p><a class="el" href="classepp_1_1CPool.html">CPool</a> uses the cId to get metadata from the <a class="el" href="classepp_1_1CMetadata.html#a43f3c16a156e3e444754a5f327dbf67b" title="Returns a copy of metadata associated with the given id.">CMetadata::GetData</a> static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cId</td><td>A ComponentId returned from <a class="el" href="classepp_1_1CMetadata.html#af34faf04e87f0d6248bdf61fb9cbef1f" title="Registers a component type on first call and returns a unique id for that type.">CMetadata::Id</a> (or IdOf) function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3922714d2f749e7253eb2cb45908f60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3922714d2f749e7253eb2cb45908f60a">&#9670;&nbsp;</a></span>CPool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">epp::CPool::CPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepp_1_1CPool.html">CPool</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Moves the ovnership of the rval's data to this <a class="el" href="classepp_1_1CPool.html">CPool</a> Clears rval, leaves metadata intact </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classepp_1_1CPool.html">CPool</a></td><td>Any <a class="el" href="classepp_1_1CPool.html">CPool</a> to be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a086db7e609e3dec0983337527b493666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086db7e609e3dec0983337527b493666">&#9670;&nbsp;</a></span>~CPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">epp::CPool::~CPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Frees owned resources </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="add00e7a2c7fd9f080c9ee8efdb71c729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add00e7a2c7fd9f080c9ee8efdb71c729">&#9670;&nbsp;</a></span>alloc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * epp::CPool::alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for one component. </p>
<p>Allocated component is always located at <a class="el" href="classepp_1_1CPool.html#ae8e2f12cf23ebbcda96b56889aceb9fc" title="Returns the number of &quot;used&quot; components.">size()</a> index (after allocation <a class="el" href="classepp_1_1CPool.html#ae8e2f12cf23ebbcda96b56889aceb9fc" title="Returns the number of &quot;used&quot; components.">size()</a> - 1) - just as vector's push_back</p>
<p>Warning;</p>
<p>EVERY ALLOCATED COMPONENT MUST BE CONSTRUCTED BEFORE NEXT ALLOC CALL. If there are 2 consecutive calls, the second one may lead to reallocation of the internal storage which will move and destroy all the components (even the uninitialized ones). This way the destructor and move constructor will be called on the uninitialized component from the first call </p><dl class="section return"><dt>Returns</dt><dd>The address of the allocated component. This addres is not permanent, every component may be moved freely by the <a class="el" href="classepp_1_1CPool.html">CPool</a> </dd></dl>

</div>
</div>
<a id="ae21df1711e13c0d620dfd1c2b03bd2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21df1711e13c0d620dfd1c2b03bd2aa">&#9670;&nbsp;</a></span>alloc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * epp::CPool::alloc </td>
          <td>(</td>
          <td class="paramtype">Idx_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for n components. </p>
<p>The same warning as above </p><dl class="section return"><dt>Returns</dt><dd>The address to the first of the allocated components. The components are stored contiguously </dd></dl>

</div>
</div>
<a id="a39d386d6fd5d4f8abefc2d770b7b1d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d386d6fd5d4f8abefc2d770b7b1d68">&#9670;&nbsp;</a></span>construct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void epp::CPool::construct </td>
          <td>(</td>
          <td class="paramtype">Idx_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the constructor on the component located at the given index. </p>
<p>Warning:</p>
<p>It is up to the caller to make sure this function is called only on components that are not yet constructed (that is, created with alloc)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the component in this pool to call the constructor on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address to the first of the allocated components. The components are stored contiguously </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">(Debug</td><td>only) Throws the AssertionFailed exception if idx is greater or equal to the <a class="el" href="classepp_1_1CPool.html#ae8e2f12cf23ebbcda96b56889aceb9fc" title="Returns the number of &quot;used&quot; components.">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7e79799d666f92fd6d419dd2be395a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e79799d666f92fd6d419dd2be395a5">&#9670;&nbsp;</a></span>construct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void epp::CPool::construct </td>
          <td>(</td>
          <td class="paramtype">Idx_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rValComp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the move constructor on the component located at the given index. </p>
<p>The same warning as above </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the component in this pool to call the move constructor on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the component located at the given location </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">(Debug</td><td>only) Throws the AssertionFailed exception if idx is greater or equal to the <a class="el" href="classepp_1_1CPool.html#ae8e2f12cf23ebbcda96b56889aceb9fc" title="Returns the number of &quot;used&quot; components.">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a388e83315cca53345d7faedce6ee4a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388e83315cca53345d7faedce6ee4a7b">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool epp::CPool::destroy </td>
          <td>(</td>
          <td class="paramtype">Idx_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the destructor on the component located at the given index. </p>
<p>The last components is moved in place of the removed one The same warning as above </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the component in this pool to call the destructor on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if deleted object was replaced with the last element (false only for the last element) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">(Debug</td><td>only) Throws the AssertionFailed exception if idx is greater or equal to the <a class="el" href="classepp_1_1CPool.html#ae8e2f12cf23ebbcda96b56889aceb9fc" title="Returns the number of &quot;used&quot; components.">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a531d5f11291ba779176d8122da6382fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531d5f11291ba779176d8122da6382fb">&#9670;&nbsp;</a></span>fitNextN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void epp::CPool::fitNextN </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The next alloc(n) call or n <a class="el" href="classepp_1_1CPool.html#add00e7a2c7fd9f080c9ee8efdb71c729" title="Allocates memory for one component.">alloc()</a> calls will not require reallocation. </p>
<p><a class="el" href="classepp_1_1CPool.html">CPool</a> will grow its capacity to the next power of 2 that will fit <a class="el" href="classepp_1_1CPool.html#ae8e2f12cf23ebbcda96b56889aceb9fc" title="Returns the number of &quot;used&quot; components.">size()</a> + n components </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of components to reserve the additional space for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0025bec412cfc415a0ed8049ac71fc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0025bec412cfc415a0ed8049ac71fc61">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepp_1_1CPool.html">CPool</a> &amp; epp::CPool::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepp_1_1CPool.html">CPool</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>
<p>Clears this <a class="el" href="classepp_1_1CPool.html">CPool</a> Moves the ovnership of the rval's data to this <a class="el" href="classepp_1_1CPool.html">CPool</a> Clears rval, leaves metadata intact </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classepp_1_1CPool.html">CPool</a></td><td>Any <a class="el" href="classepp_1_1CPool.html">CPool</a> to be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca2b05a74ae78bda6c760d5e477ae3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2b05a74ae78bda6c760d5e477ae3a7">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * epp::CPool::operator[] </td>
          <td>(</td>
          <td class="paramtype">Idx_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the component located at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the component in this pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Pointer to the component located at the given index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">(Debug</td><td>only) Throws the AssertionFailed exception if idx is greater or equal to the <a class="el" href="classepp_1_1CPool.html#ae8e2f12cf23ebbcda96b56889aceb9fc" title="Returns the number of &quot;used&quot; components.">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a709ac5e7931265dd9ada9681522921b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709ac5e7931265dd9ada9681522921b3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void const  * epp::CPool::operator[] </td>
          <td>(</td>
          <td class="paramtype">Idx_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the component located at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the component in this pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Pointer to the component located at the given index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">(Debug</td><td>only) Throws the AssertionFailed exception if idx is greater or equal to the <a class="el" href="classepp_1_1CPool.html#ae8e2f12cf23ebbcda96b56889aceb9fc" title="Returns the number of &quot;used&quot; components.">size()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4075ebdecfdf17cfbf73bbc0c1157b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4075ebdecfdf17cfbf73bbc0c1157b05">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void epp::CPool::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>newReserved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the capacity to exactly newReserved. </p>
<p>If newReserved &lt; <a class="el" href="classepp_1_1CPool.html#ae8e2f12cf23ebbcda96b56889aceb9fc" title="Returns the number of &quot;used&quot; components.">size()</a> then components that don't fit get destroyed</p>
<p>If newReserved == <a class="el" href="classepp_1_1CPool.html#ac9e298ce6457a0092240dc0d617da5c8" title="Returns the capacity of the pool (how many components can it fit without reallocation)">capacity()</a> nothing happens</p>
<p>If newReserved != <a class="el" href="classepp_1_1CPool.html#ac9e298ce6457a0092240dc0d617da5c8" title="Returns the capacity of the pool (how many components can it fit without reallocation)">capacity()</a> reallocates to set capacity to newReserved </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newReserved</td><td>New capacity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ECSpp/internal/<a class="el" href="CPool_8h_source.html">CPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
